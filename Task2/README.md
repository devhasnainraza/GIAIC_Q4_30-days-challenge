# **Task 2**

---

## ğŸ“ Part A â€” Theory (Short Questions)

### 1. Nine Pillars Understanding

**Q: Why is using AI Development Agents (like Gemini CLI) for repetitive setup tasks better for your growth as a system architect?**
Using development agents helps eliminate repetitive setup work, allowing me to stay focused on architecture, logic, and system-level thinking instead of wasting time on boilerplate tasks. When the boring work is automated, I can use my time to think like a system designer instead of a code typist â€” which is exactly the mindset shift needed in the AI era.

**Q: Explain how the Nine Pillars of AIDD help a developer grow into an M-Shaped Developer.**
The Nine Pillars give developers a complete ecosystem covering specs, testing, agents, orchestration, and evaluation. Because of these pillars, a single developer can work across multiple areas (design, coding, testing, automation, planning). This naturally leads to M-shaped skills â€” deep in several domains instead of just one.

---

### 2. Vibe Coding vs Specification-Driven Development

**Q: Why does Vibe Coding usually create problems after one week?**
Vibe coding relies too much on intuition instead of a clear plan. After a week, the codebase becomes harder to maintain, features become confusing, and no oneâ€”including the original developerâ€”fully understands why decisions were made. It feels fast at first but collapses later.

**Q: How would Specification-Driven Development prevent those problems?**
SDD forces you to think before you code. By writing executable specs early, you create a shared understanding and eliminate ambiguity. It prevents chaos, reduces rewrites, and ensures the system remains stable and scalable.

---

### 3. Architecture Thinking

**Q: How does architecture-first thinking change the role of a developer in AIDD?**
Architecture-first thinking shifts the developerâ€™s role from â€œcoderâ€ to â€œdesigner.â€ Instead of focusing only on syntax, the developer thinks about layers, structure, components, and how everything fits together. This is how AI-enabled developers evolve into system architects.

**Q: Explain why developers must think in layers and systems instead of raw code.**
Thinking in layers allows codebases to scale and evolve. Raw code thinking is surface-level and leads to technical debt. Layered thinking forces you to design the structure first, which means you can integrate AI tools, testing, agents, and automation later without breaking the system.

---

## ğŸ“ Part B â€” Practical Task (CLI Screenshot + Output)

### ğŸ”¹ My Prompt (CLI Example):

```
Generate a 1-paragraph specification for an email validation function. Requirements:
- Must contain â€œ@â€
- Must contain a valid domain like .com or .org
- Should return clear error messages
```

### ğŸ”¹ Output (Screenshot):

![CLI Screenshot](cli-output.png)

---

## ğŸ“ Part C â€” Multiple Choice Questions

| # | Answer |
| - | ------ |
| 1 | B      |
| 2 | B      |
| 3 | B      |
| 4 | B      |
| 5 | C      |

---

## ğŸŒŸ Reflection

This task helped me understand that modern development is no longer just about writing code â€” itâ€™s about designing intelligent systems. Concepts like SDD, architecture thinking, and development agents arenâ€™t optional anymore â€” theyâ€™re the foundation of the AI-Native era. If we want to grow beyond traditional roles, we must shift from typing code to thinking like system-level problem solvers. AI doesnâ€™t eliminate developers â€” it upgrades them.

---

## ğŸš€ Prepared By

**Muhammad Hasnain**

AIDD 30-Day Challenge Participant




